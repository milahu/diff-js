// TODO compile fn localExtrema with inlined data getters -> faster?

const debug = false;
const d = debug ? '' : '//';

function get_loop_body(last_state) {
  const s = (last_state == 'was_rising') ? ((a, b) => a) : ((a, b) => b);
  return `\
      // was ${s('rising', 'falling')}
      if (thisY ${s('>=', '<=')} ${s('lastMax', 'lastMin')} ${s('-', '+')} yTolerance) {
        // still ${s('rising', 'falling')}
        // detect ${s('high', 'low')} plateau
        if (thisY ${s('<', '>')} ${s('lastMax', 'lastMin')} ${s('+', '-')} yTolerance) {
          // thisY is inside the tolerance bands
          ${d}console.log(\`localExtrema: i \${i}: y \${thisY} is near ${s('lastMax', 'lastMin')} \${${s('lastMax', 'lastMin')}}. plateauLength -> \${plateauLength + 1} \`);
          plateauLength++;
        }
        else {
          if (plateauLength > 0) {
            ${addPlateau(
              options.result('resultArray', 'i - plateauLength - 1'),
              options.result('resultArray', 'i - 1')
            )}
            ${d}console.log(\`localExtrema: i \${i}: found ${s('rising', 'falling')} plateau: plateauLength \${plateauLength} + start \${i - plateauLength-1} + end \${i-1}\`);
          }
          plateauLength = 0;
        }
        ${s('lastMax', 'lastMin')} = Math.${s('max', 'min')}(${s('lastMax', 'lastMin')}, thisY); // thisY can be ${s('smaller', 'bigger')} than ${s('lastMax', 'lastMin')}
      }
      else {
        // stopped ${s('rising', 'falling')}
        plateauLength = 0;
        // find x interval of last ${s('maximum', 'minimum')}
        let iStart = i - 1;
        while (${options.y('yArray', 'iStart')} ${s('>=', '<=')} ${s('lastMax', 'lastMin')} ${s('-', '+')} yTolerance) {
          iStart--;
        }
        if ((i - iStart) >= 2) {
          ${last_state == 'was_rising'
            ? addMaximum(
              options.result('resultArray', 'iStart + 1'),
              options.result('resultArray', 'i - 1'),
            )
            : addMinimum(
              options.result('resultArray', 'iStart + 1'),
              options.result('resultArray', 'i - 1'),
            )
          }
        }
        else {
          ${last_state == 'was_rising'
            ? addMaximum(
              options.result('resultArray', 'iStart'),
              options.result('resultArray', 'i'),
            )
            : addMinimum(
              options.result('resultArray', 'iStart'),
              options.result('resultArray', 'i'),
            )
          }
        }
        // (plateau or) ${s('falling', 'rising')}
        lastSlope = ${s('-1', '1')};
        ${s('lastMin', 'lastMax')} = thisY;
      }`;
}

function get_filename() {
  const path = typeof(__filename) == 'undefined' ? new URL(import.meta.url).pathname : __filename;
  return path.slice(path.lastIndexOf('/') + 1);
}

const options = {
  // data is array of y values
  length: data => `${data}.length`,
  y: (data, idx) => `${data}[${idx}]`,
  result: (data, idx) => `${idx}`,
  resultArray: (data) => `${data}`,
  yArray: (data) => `${data}`,
}

function addMaximum(a, b) {
  //return `maxima.push([${a}, ${b}]); extrema.push([${a}, ${b}]);`;
  //return `maxima[maxima.length] = extrema[extrema.length] = [${a}, ${b}];`;
  return `const ab = [${a}, ${b}]; maxima.push(ab); extrema.push(ab);`;
}

function addMinimum(a, b) {
  //return `minima.push([${a}, ${b}]); extrema.push([${a}, ${b}]);`;
  //return `minima[minima.length] = extrema[extrema.length] = [${a}, ${b}];`;
  return `const ab = [${a}, ${b}]; minima.push(ab); extrema.push(ab);`;
}

function addPlateau(a, b) {
  //return `plateaus.push([${a}, ${b}]); extrema.push([${a}, ${b}]);`;
  //return `plateaus[plateaus.length] = extrema[extrema.length] = [${a}, ${b}];`;
  return `const ab = [${a}, ${b}]; plateaus.push(ab); extrema.push(ab);`;
}



function localExtrema_source() {

  return `\
// this program was generated by ${get_filename()}

// https://github.com/balint42/diff.js
// differentiation, integration, find local minima and maxima

// similar project:
// https://github.com/efekarakus/d3-peaks
// will only find local maxima (peaks)

/**
 * Find local maxima and minima in a list of values.
 *
 * For every extreme point, return one x interval.
 * The y values of the interval start and end
 * *can* be significantly different from the extreme point's y value.
 *
 * yTolerance depends on the data fluctuations:
 * smaller values mean greater reliability in finding extrema
 * but also greater chance of confusing noise
 * with a local minimum or maximum (false positives).
 *
 * @author Balint Morvai <balint@morvai.de>
 * @license http://en.wikipedia.org/wiki/MIT_License MIT License
 * @param data
 * @param options
 * @option yTolerance
 * @option result, y, getLength: getter functions for custom data format
 * @option nonextrema: also return non-extreme intervals
 * @returns { extrema: interval[], minima: interval[], maxima: interval[], nonextrema: interval[] }
 * @type interval = [xStart, xEnd]
 */

export function localExtrema(data, options) {

  // TODO better way to find start of x intervals (detect plateaus) (avoid looping back)
  // TODO also return plateaus who are not min plateaus and not max plateaus

  const defaultOptions = {
    yTolerance: 0.1,
    nonextrema: true,
  };
  options = Object.assign(defaultOptions, options);
  const dataLength = ${options.length('data')};
  const yArray = ${options.yArray('data')};
  const resultArray = ${options.resultArray('data')};
  if (dataLength < 3) {
    // we need at least three points to analyze extreme points:
    // first derivation is zero and second derivation is nonzero
    return { extrema: [], maxima: [], minima: [], plateaus: [], nonextrema: [] };
  }
  const { yTolerance } = options;
  const lastIndex = dataLength - 1;
  let lastSlope; // -1: falling, +1: rising
  const extrema = [];
  const maxima = [];
  const minima = [];
  const plateaus = [];
  let lastMin = ${options.y('yArray', '0')};
  let lastMax = ${options.y('yArray', '0')};
  let lastY = ${options.y('yArray', '0')};
  let thisY = ${options.y('yArray', '1')};

  ${d}${'console.log(`localExtrema: data ${JSON.stringify(data)}`);'}
  ${d}console.log(\`localExtrema: i 0 + y \${${options.y('yArray', '0')}} + lastSlope ?? + lastMin \${lastMin} + lastMax \${lastMax}\`);
  ${d}console.log(\`localExtrema: i 1 + y \${${options.y('yArray', '1')}} + lastSlope ?? + lastMin \${lastMin} + lastMax \${lastMax}\`);

  let i = 2; // next point
  let plateauLength = 0;

  // start of array
  if (thisY < (lastMax - yTolerance)) {
    // falling
    lastSlope = -1;
    lastMin = thisY;
  }
  else if (thisY > (lastMin + yTolerance)) {
    // rising
    lastSlope = 1;
    lastMax = thisY;
  }
  else {
    // plateau at start of array
    // seek to end of plateau
    for (; i < dataLength; i++) {
      thisY = ${options.y('yArray', 'i')};
      ${d}${"console.log(`localExtrema: i ${i} + y ${thisY} + lastSlope ${lastSlope == 1 ? '+1' : lastSlope} + lastMin ${lastMin} + lastMax ${lastMax}`);"}
      if (thisY < (lastMax - yTolerance)) {
        // maximum plateau + falling
        if (i > 1) {
          ${addMaximum(
            options.result('resultArray', '0'),
            options.result('resultArray', 'i - 1'),
          )}
        }
        else {
          ${addMaximum(
            options.result('resultArray', '0'),
            options.result('resultArray', 'i'),
          )}
        }
        lastSlope = -1;
        lastMin = thisY;
        break;
      }
      else if (thisY > (lastMin + yTolerance)) {
        // minimum plateau + rising
        if (i > 1) {
          ${addMinimum(
            options.result('resultArray', '0'),
            options.result('resultArray', 'i - 1'),
          )}
        }
        else {
          ${addMinimum(
            options.result('resultArray', '0'),
            options.result('resultArray', 'i'),
          )}
        }
        lastSlope = 1;
        lastMax = thisY;
        break;
      }
    }
    i++; // needed after break-ing out of the for-loop
  }
  ${d}${'console.log(`localExtrema: i ${i}: done start of array`);'}

  for (; i < dataLength; i++) {
    thisY = ${options.y('yArray', 'i')};
    ${d}${"console.log(`localExtrema: i ${i} + y ${thisY} + lastSlope ${lastSlope == 1 ? '+1' : lastSlope} + lastMin ${lastMin} + lastMax ${lastMax}`);"}
    if (lastSlope == 1) {
${get_loop_body('was_rising')}
    }
    //else if (lastSlope == -1) {
    else {
${get_loop_body('was_falling')}
    }
  }
  ${d}${'console.log(`localExtrema: done middle of array`);'}

  // end of array
  i = lastIndex;
  if (plateauLength > 0) {
    // plateau at end of array
    // plateauLength is already minimal, no need to minimize
    if (thisY > lastMax - yTolerance) {
      // maximum plateau
      ${addMaximum(
        options.result('resultArray', 'i - plateauLength'),
        options.result('resultArray', 'i')
      )}
    }
    else {
      // minimum plateau
      ${addMinimum(
        options.result('resultArray', 'i - plateauLength'),
        options.result('resultArray', 'i')
      )}
    }
  }

  if (options.nonextrema) {
    // find complementary intervals, where data is not extreme
    // use the same interval delimiters as in the extrema array (xStart, xEnd)
    const nonextrema = [];
    if (extrema.length == 0) {
      // all values are non-extreme
      nonextrema.push([${options.result('resultArray', '0')}, ${options.result('resultArray', 'lastIndex')}]);
    }
    else {
      var a = ${options.result('resultArray', '0')};
      var b = extrema[0][0];
      if (a != b) {
        // data start is no plateau
        nonextrema.push([a, b]);
      }
      for (let i = 0; i < extrema.length - 1; i++) {
        nonextrema.push([
          extrema[i][1],
          extrema[i + 1][0]
        ]);
      }
      var a = extrema[extrema.length - 1][1];
      var b = ${options.result('resultArray', 'lastIndex')};
      if (a != b) {
        // data end is no plateau
        nonextrema.push([a, b]);
      }
    }
    return { extrema, maxima, minima, plateaus, nonextrema }
  }

  return { extrema, maxima, minima, plateaus };
}`; // console.log will add newline
}

console.log(localExtrema_source());

